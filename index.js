const {
    WAConnection,
    MessageType,
    Presence,
    Mimetype,
    GroupSettingChange
} = require('@adiwajshing/baileys')
const { color, bgcolor } = require('./lib/color')
const { help } = require('./src/help')
const { jogos } = require('./src/jogos')
const { skiller } = require('./src/skiller')
const { plays } = require('./src/plays')
const { menufig } = require('./src/menufig')
const { utils } = require('./src/utils')
const { modapk } = require('./src/modapk')
const { pack18 } = require('./src/pack18')
const { ajudantes } = require('./src/ajudantes')
const { imunes } = require('./src/imunes')
const { wait, getBuffer, h2k, generateMessageID, getGroupAdmins, getRandom, banner, start, info, success, close } = require('./lib/functions')
const { fetchJson, fetchText } = require('./lib/fetcher')
const { recognize } = require('./lib/ocr')
const fs = require('fs')
const moment = require('moment-timezone')
const { exec } = require('child_process')
const fetch = require('node-fetch')
const ffmpeg = require('fluent-ffmpeg')
const { removeBackgroundFromImageFile } = require('remove.bg')
const lolis = require('lolis.life')
const loli = new lolis()
const welkom = JSON.parse(fs.readFileSync('./src/welkom.json'))
const nsfw = JSON.parse(fs.readFileSync('./src/nsfw.json'))
const samih = JSON.parse(fs.readFileSync('./src/simi.json'))
const setting = JSON.parse(fs.readFileSync('./src/settings.json'))
const vcard = 'BEGIN:VCARD\n'
            + 'VERSION:3.0\n' 
            + 'FN:JOHN E BRAZ\n' // Seu nome
            + 'ORG:Jarvis BOT;\n' // Nome do bot
            + 'TEL;type=CELL;type=VOICE;waid=5511941212232:+55 11 94121-2232\n' //Seu n√∫mero Whatsapp
            + 'END:VCARD'
prefix = setting.prefix
blocked = []

     //_ARQUIVOS ANTIS
const antifake = JSON.parse(fs.readFileSync('./src/antifake.json'))
//_FIM DOS ARQUIVOS ANTIS

function kyun(seconds){
  function pad(s){
    return (s < 10 ? '0' : '') + s;
  }
  var hours = Math.floor(seconds / (60*60));
  var minutes = Math.floor(seconds % (60*60) / 60);
  var seconds = Math.floor(seconds % 60);

  //return pad(hours) + ':' + pad(minutes) + ':' + pad(seconds)
  return `${pad(hours)} Jam ${pad(minutes)} Menit ${pad(seconds)} Detik`
}

async function starts() {
	const client = new WAConnection()
	client.logger.level = 'warn'
	console.log(banner.string)
	client.on('qr', () => {
		console.log(color('[','white'), color('!','red'), color(']','white'), color(' Escaneie o c√≥digo com WhatsApp Web no n√∫mero do seu BOT'))
	})

	fs.existsSync('./BarBar.json') && client.loadAuthInfo('./BarBar.json')
	client.on('connecting', () => {
		start('2', 'Conectando QRCode...')
	})
	client.on('open', () => {
		success('2', 'Jarvis BOT Conectado com Sucesso!')
	})
	await client.connect({timeoutMs: 30*1000})
        fs.writeFileSync('./BarBar.json', JSON.stringify(client.base64EncodedAuthInfo(), null, '\t'))

	client.on('group-participants-update', async (anu) => {
		if(antifake.includes(anu.jid)) {
	const mdata = await client.groupMetadata(anu.jid)
			if (anu.action == 'add'){
				num = anu.participants[0]
				if(!num.split('@')[0].startsWith(55)) {
					client.sendMessage(mdata.id, ' ‚õπÔ∏è‚õπÔ∏èNumeros Estrangeiros n√£o s√£o permitidos nesse grupo, consulte um AdministradorüëãüèåÔ∏è', MessageType.text)
					setTimeout(async function () {
						client.groupRemove(mdata.id, [num])
					}, 1000)
			    }
			}
		}
		if (!welkom.includes(anu.jid)) return
		try {
			const mdata = await client.groupMetadata(anu.jid)
			console.log(anu)
			if (anu.action == 'add') {
				num = anu.participants[0]
				try {
					ppimg = await client.getProfilePicture(`${anu.participants[0].split('@')[0]}@c.us`)
				} catch {
					ppimg = 'https://i0.wp.com/www.gambarunik.id/wp-content/uploads/2019/06/Top-Gambar-Foto-Profil-Kosong-Lucu-Tergokil-.jpg'
				}
				teks = `ùêéùê©ùêö @${num.split('@')[0]}\nùòâùò¶ùòÆ ùò∑ùò™ùòØùò•ùò∞ ùò¢ùò∞ ùòéùò≥ùò∂ùò±ùò∞ *${mdata.subject}*\n\nùêãùêûùê¢ùêö ùêöùê¨ ùê´ùêûùê†ùê´ùêöùê¨ ùêùùê® ùê†ùê´ùêÆùê©ùê® ùê©ùêöùê´ùêö ùêß√£ùê® ùê¨ùêûùê´ ùêõùêöùêßùê¢ùêùùê®‚ù§Ô∏è`
				let buff = await getBuffer(ppimg)
				client.sendMessage(mdata.id, buff, MessageType.image, {caption: teks, contextInfo: {"mentionedJid": [num]}})
				client.sendMessage(from, tujuh, MessageType.audio, {quoted: mek, mimetype: 'audio/mp4', ptt:true})
			} else if (anu.action == 'remove') {
				num = anu.participants[0]
				try {
					ppimg = await client.getProfilePicture(`${num.split('@')[0]}@c.us`)
				} catch {
					ppimg = 'https://i0.wp.com/www.gambarunik.id/wp-content/uploads/2019/06/Top-Gambar-Foto-Profil-Kosong-Lucu-Tergokil-.jpg'
				}
				teks = `  
    .      „ÄÄ„ÄÇ„ÄÄ„ÄÄ„ÄÄ„ÄÄ‚Ä¢„ÄÄ    „ÄÄÔæü„ÄÄ„ÄÄ„ÄÇ
    „ÄÄ„ÄÄ.„ÄÄ„ÄÄ„ÄÄ.„ÄÄ„ÄÄ„ÄÄ  „ÄÄ„ÄÄ.„ÄÄ„ÄÄ„ÄÄ„ÄÄ„ÄÄ„ÄÇ„ÄÄ„ÄÄ   „ÄÇ„ÄÄ.
    „ÄÄ.„ÄÄ„ÄÄ      „ÄÇ„ÄÄ        ‡∂û   „ÄÇ„ÄÄ    .    ‚Ä¢
    ‚Ä¢            @${num.split('@')[0]}was E j e c t e d
                      1 impostor restante   „ÄÇ„ÄÄ.
    „ÄÄ „ÄÄ„ÄÄ„ÄÇ„ÄÄ„ÄÄ „ÄÄ„ÄÄ„ÄÄ„ÄÄÔæü„ÄÄ„ÄÄ„ÄÄ.„ÄÄ      „ÄÄ„ÄÄ
ùêÄùêØùê¢ùê¨ùê® ùê©ùêöùê´ùêö ùêØùê®ùêú√™ ùê™ùêÆùêû ùê¨ùêöùê¢ùêÆ @${num.split('@')[0]} ùêÅùê®ùê¢ ùêõùê®ùê¢ ùêõùê®ùê¢,ùêõùê®ùê¢ ùêùùêö ùêúùêöùê´ùêö ùê©ùê´ùêûùê≠ùêö ùê™ùêÆùêûùê¶ ùê¨ùêöùê¢ùêÆ ùêùùê® ùê†ùê´ùêÆùê©ùê® ùê¶ùêöùê¶ùêö ùêö ùê©ùê¢ùê§ùêö ùêùùê® ùêúùêöùê©ùêûùê≠ùêöüòÇüëã`
				        
    
				let buff = await getBuffer(ppimg)
				client.sendMessage(mdata.id, buff, MessageType.image, {caption: teks, contextInfo: {"mentionedJid": [num]}})
			}
		} catch (e) {
			console.log('Error : %s', color(e, 'red'))
		}
	})

	client.on('CB:Blocklist', json => {
            if (blocked.length > 2) return
	    for (let i of json[1].blocklist) {
	    	blocked.push(i.replace('c.us','s.whatsapp.net'))
	    }
	})

	client.on('chat-update', async (mek) => {
		try {
            if (!mek.hasNewMessage) return
            mek = mek.messages.all()[0]
			if (!mek.message) return
			if (mek.key && mek.key.remoteJid == 'status@broadcast') return
			if (mek.key.fromMe) return
			global.prefix
			global.blocked
			const content = JSON.stringify(mek.message)
			const from = mek.key.remoteJid
			const type = Object.keys(mek.message)[0]
			const apiKey = setting.apiKey // contact me on whatsapp wa.me/11941212232
			const { text, extendedText, contact, location, liveLocation, image, video, sticker, document, audio, product } = MessageType
			const time = moment.tz('Brasil/Brasilia').format('DD/MM HH:mm:ss')
			body = (type === 'conversation' && mek.message.conversation.startsWith(prefix)) ? mek.message.conversation : (type == 'imageMessage') && mek.message.imageMessage.caption.startsWith(prefix) ? mek.message.imageMessage.caption : (type == 'videoMessage') && mek.message.videoMessage.caption.startsWith(prefix) ? mek.message.videoMessage.caption : (type == 'extendedTextMessage') && mek.message.extendedTextMessage.text.startsWith(prefix) ? mek.message.extendedTextMessage.text : ''
			budy = (type === 'conversation') ? mek.message.conversation : (type === 'extendedTextMessage') ? mek.message.extendedTextMessage.text : ''
			const command = body.slice(1).trim().split(/ +/).shift().toLowerCase()
			const args = body.trim().split(/ +/).slice(1)
			const isCmd = body.startsWith(prefix)

			mess = {
				wait: 'Estou fazendo ‚åõ',
				success: '‚úîÔ∏è Deu certo ‚úîÔ∏è',
				error: {
					stick: '‚ùå Falha, ocorreu um erro ao converter a imagem em um adesivo ‚ùå',
					Iv: '‚ùå Link inv√°lido, tente novamente ‚ùå'
				},
				only: {
					group: '‚ùå Este comando s√≥ pode ser usado em grupos! ‚ùå',
					premium: '[‚ùó] ESTE PEDIDO √â SO PARA *USU√ÅRIOS PREMIUMS*',
					ownerG: '‚ùå Este comando s√≥ pode ser usado pelo dono! ‚ùå',
					ownerB: '‚ùå Este comando s√≥ pode ser usado pelo meu dono! ‚ùå',
					admin: '‚ùå Este comando s√≥ pode ser usado por Administradores de grupo! ‚ùå',
					Badmin: '‚ùå Este comando s√≥ pode ser usado quando o bot se torna Administrador! ‚ùå'
				}
			}

			const botNumber = client.user.jid
			const ownerNumber = [`${setting.ownerNumber}@s.whatsapp.net`] // substitua isso pelo seu n√∫mero
            const mod = [ownerNumber,"${setting.mod}@s.whatsapp.net"]//mude o seu numero
            const adminbotnumber = ["${setting.adminbotnumber}@s.whatsapp.net"]//mude o seu numero
			const frendsowner = ["${setting.frendsowner}@s.whatsapp.net"]//mude o seu numero
            const premium = ["11941212232@s.whatsapp.net","${setting.vip2}@s.whatsapp.net","${setting.vip3}@s.whatsapp.net","${setting.vip4}@s.whatsapp.net","${setting.vip5}@s.whatsapp.net","${setting.vip6}@s.whatsapp.net","${setting.vip7}@s.whatsapp.net","${setting.vip8}@s.whatsapp.net","${setting.vip9}@s.whatsapp.net","${setting.vip10}@s.whatsapp.net",]
			const isGroup = from.endsWith('@g.us')
			const sender = isGroup ? mek.participant : mek.key.remoteJid
			const isPremium = premium.includes(sender)
			const groupMetadata = isGroup ? await client.groupMetadata(from) : ''
			const groupName = isGroup ? groupMetadata.subject : ''
			const groupId = isGroup ? groupMetadata.jid : ''
			const groupMembers = isGroup ? groupMetadata.participants : ''
			const groupAdmins = isGroup ? getGroupAdmins(groupMembers) : ''
			const isBotGroupAdmins = groupAdmins.includes(botNumber) || false
			const isGroupAdmins = groupAdmins.includes(sender) || false
			const isWelkom = isGroup ? welkom.includes(from) : false
			const isNsfw = isGroup ? nsfw.includes(from) : false
            const isAntiFake = isGroup ? antifake.includes(from) : false
			const isOwner = ownerNumber.includes(sender)
            pushname = client.contacts[sender] != undefined ? client.contacts[sender].vname || client.contacts[sender].notify : undefined
			const ismod = mod.includes(sender)
			const isadminbot = adminbotnumber.includes(sender)
			const isfrendsowner = frendsowner.includes(sender)
			const isUrl = (url) => {
			    return url.match(new RegExp(/https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)/, 'gi'))
			}
			const reply = (teks) => {
				client.sendMessage(from, teks, text, {quoted:mek})
			}
			const sendMess = (hehe, teks) => {
				client.sendMessage(hehe, teks, text)
			}
			const mentions = (teks, memberr, id) => {
				(id == null || id == undefined || id == false) ? client.sendMessage(from, teks.trim(), extendedText, {contextInfo: {"mentionedJid": memberr}}) : client.sendMessage(from, teks.trim(), extendedText, {quoted: mek, contextInfo: {"mentionedJid": memberr}})
			}

			colors = ['red','white','black','blue','yellow','green']
			const isMedia = (type === 'imageMessage' || type === 'videoMessage')
			const isQuotedImage = type === 'extendedTextMessage' && content.includes('imageMessage')
			const isQuotedVideo = type === 'extendedTextMessage' && content.includes('videoMessage')
			const isQuotedSticker = type === 'extendedTextMessage' && content.includes('stickerMessage')
			if (!isGroup && isCmd) console.log('\x1b[1;31m~\x1b[1;37m>', '[\x1b[1;32mEXEC\x1b[1;37m]', time, color(command), 'from', color(sender.split('@')[0]), 'args :', color(args.length))
			if (!isGroup && !isCmd) console.log('\x1b[1;31m~\x1b[1;37m>', '[\x1b[1;31mRECV\x1b[1;37m]', time, color('Message'), 'from', color(sender.split('@')[0]), 'args :', color(args.length))
			if (isCmd && isGroup) console.log('\x1b[1;31m~\x1b[1;37m>', '[\x1b[1;32mEXEC\x1b[1;37m]', time, color(command), 'from', color(sender.split('@')[0]), 'in', color(groupName), 'args :', color(args.length))
			if (!isCmd && isGroup) console.log('\x1b[1;31m~\x1b[1;37m>', '[\x1b[1;31mRECV\x1b[1;37m]', time, color('Message'), 'from', color(sender.split('@')[0]), 'in', color(groupName), 'args :', color(args.length))
			let authorname = client.contacts[from] != undefined ? client.contacts[from].vname || client.contacts[from].notify : undefined	
			if (authorname != undefined) { } else { authorname = groupName }	
			
			function addMetadata(packname, author) {	
				if (!packname) packname = 'PRIVATE'; if (!author) author = 'Skiller';	
				author = author.replace(/[^a-zA-Z0-9]/g, '');	
				let name = `${author}_${packname}`
				if (fs.existsSync(`./src/stickers/${name}.exif`)) return `./src/stickers/${name}.exif`
				const json = {	
					"sticker-pack-name": packname,
					"sticker-pack-publisher": author,
				}
				const littleEndian = Buffer.from([0x49, 0x49, 0x2A, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00])	
				const bytes = [0x00, 0x00, 0x16, 0x00, 0x00, 0x00]	

				let len = JSON.stringify(json).length	
				let last	

				if (len > 256) {	
					len = len - 256	
					bytes.unshift(0x01)	
				} else {	
					bytes.unshift(0x00)	
				}	

				if (len < 16) {	
					last = len.toString(16)	
					last = "0" + len	
				} else {	
					last = len.toString(16)	
				}	

				const buf2 = Buffer.from(last, "hex")	
				const buf3 = Buffer.from(bytes)	
				const buf4 = Buffer.from(JSON.stringify(json))	

				const buffer = Buffer.concat([littleEndian, buf2, buf3, buf4])	

				fs.writeFile(`./src/stickers/${name}.exif`, buffer, (err) => {	
					return `./src/stickers/${name}.exif`	
				})	
				
}
			switch(command) {
case 'bugreport':
const bug = body.slice(10)
 if (args.length > 300) return client.sendMessage(from, 'M√°ximo 300 caracteres', msgType.text, {quoted: mek})
var nomor = mek.participant
teks1 = `[REPORT]\nDe: wa.me/${sender.split("@s.whatsapp.net")[0]}\nErro ou bug: ${bug}`
var options = {
 text: teks1, 
contextInfo: {mentionedJid: [sender]}, 
}
client.sendMessage('5511941212232@s.whatsapp.net', options, text, {quoted: mek})
reply("Mensagem enviada para os Administradores. Se por acaso haja Spam, √© numero bloqueado.")
break
				//_MENUS
				case 'help':
				case 'menu':
wew = fs.readFileSync('./assets/jarvisbanner.png')
                client.sendMessage(from, wew, image, {quoted: { key: { fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "imageMessage": { "url": "https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc", "mimetype": "image/jpeg", "caption": "BOT VERIFICADO ‚úîÔ∏è", "fileSha256": "+Ia+Dwib70Y1CWRMAP9QLJKjIJt54fKycOfB2OEZbTU=", "fileLength": "28777", "height": 1080, "width": 1079, "mediaKey": "vXmRR7ZUeDWjXy5iQk17TrowBzuwRya0errAFnXxbGc=", "fileEncSha256": "sR9D2RS5JSifw49HeBADguI23fWDz1aZu4faWG/CyRY=", "directPath": "/v/t62.7118-24/21427642_840952686474581_572788076332761430_n.enc?oh=3f57c1ba2fcab95f2c0bb475d72720ba&oe=602F3D69", "mediaKeyTimestamp": "1610993486", "jpegThumbnail": fs.readFileSync('./assets/jarvis.png')} } }, caption: help(prefix) })
				  break
case 'ajudantes':
                    client.sendMessage(from, ajudantes(prefix) , text, {quoted: mek, quoted: { key: { fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "imageMessage": { "url": "https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc", "mimetype": "image/jpeg","caption": " AJUDANTES E PARCERIAS ü§†", 'jpegThumbnail': fs.readFileSync('kk/sticker/botlogo.webp')}}}})					
                break
case 'pack':
                    if (!isPremium) return reply(mess.only.premium)
                    client.sendMessage(from, pack18(prefix) , text, {quoted: mek, quoted: { key: { fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "imageMessage": { "url": "https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc", "mimetype": "image/jpeg","caption": "By Skiller", 'jpegThumbnail': fs.readFileSync('kk/sticker/botlogo.webp')}}}})					
                break
case 'utils':
		client.sendMessage(from, utils(prefix) , text, {quoted: mek, quoted: { key: { fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "imageMessage": { "url": "https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc", "mimetype": "image/jpeg","caption": "Utilizaveis", 'jpegThumbnail': fs.readFileSync('kk/sticker/botlogo.webp')}}}})					
                break
case 'plays':
		client.sendMessage(from, plays(prefix) , text, {quoted: mek, quoted: { key: { fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "imageMessage": { "url": "https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc", "mimetype": "image/jpeg","caption": "Plays de Musica", 'jpegThumbnail': fs.readFileSync('kk/sticker/botlogo.webp')}}}})					
                break
case 'menuadm':
					client.sendMessage(from, menuadm(prefix) , text, {quoted: mek, quoted: { key: { fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "imageMessage": { "url": "https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc", "mimetype": "image/jpeg","caption": "Menu administrador üë∫", 'jpegThumbnail': fs.readFileSync('kk/sticker/botlogo.webp')}}}})					
                break
case 'modapk':
               if (!isPremium) return reply(mess.only.premium)
                    client.sendMessage(from, modapk(prefix) , text, {quoted: mek, quoted: { key: { fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "imageMessage": { "url": "https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc", "mimetype": "image/jpeg","caption": "Apks premium", 'jpegThumbnail': fs.readFileSync('kk/sticker/botlogo.webp')}}}})					
                break
case 'skiller':
					client.sendMessage(from, skiller(prefix) , text, {quoted: mek, quoted: { key: { fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "imageMessage": { "url": "https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc", "mimetype": "image/jpeg","caption": "Comandos do dono", 'jpegThumbnail': fs.readFileSync('kk/sticker/botlogo.webp')}}}})					
                break
case 'menufig':
					client.sendMessage(from, menufig(prefix) , text, {quoted: mek, quoted: { key: { fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "imageMessage": { "url": "https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc", "mimetype": "image/jpeg","caption": "Sticker Maker", 'jpegThumbnail': fs.readFileSync('kk/sticker/botlogo.webp')}}}})					
                break
case 'imunes':
					client.sendMessage(from, imunes(prefix) , text, {quoted: mek, quoted: { key: { fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "imageMessage": { "url": "https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc", "mimetype": "image/jpeg","caption": "Imunidade 999+", 'jpegThumbnail': fs.readFileSync('kk/sticker/botlogo.webp')}}}})					
                break
case 'jogos':
					client.sendMessage(from, jogos(prefix) , text, {quoted: mek, quoted: { key: { fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "imageMessage": { "url": "https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc", "mimetype": "image/jpeg","caption": "Divers√£o", 'jpegThumbnail': fs.readFileSync('kk/sticker/botlogo.webp')}}}})					
                break
case 'antifake':
					try {
					if (!isGroup) return reply(mess.only.group)
					if (!isGroupAdmins) return reply(mess.only.admin)
					if (args.length < 1) return reply('Hmmmm')
					if (Number(args[0]) === 1) {
						if (isAntiFake) return reply('Ja esta ativo')
						antifake.push(from)
						fs.writeFileSync('./src/antifake.json', JSON.stringify(antifake))
						reply('Ativou com sucesso o recurso de antifake neste grupo‚úîÔ∏è')
					} else if (Number(args[0]) === 0) {
						antifake.splice(from, 1)
						fs.writeFileSync('./src/antifake.json', JSON.stringify(antifake))
						reply('Desativou com sucesso o recurso de antifake neste grupo‚úîÔ∏è')
					} else {
						reply('1 para ativar, 0 para desativar')
					}
					} catch {
						reply('Deu erro, tente novamente :/')
					}
                break
				//_DONO
				case 'delete':
				case 'del':
				case 'd':  
					client.deleteMessage(from, { id: mek.message.extendedTextMessage.contextInfo.stanzaId, remoteJid: from, fromMe: true })
					break
				case 'dono':
					memein = await kagApi.memeindo()
					buffer = await getBuffer(`https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR4V_4fdvF8rluX0T3KKGOvY0TusMwx7nVWtw&usqp=CAU`)
					client.sendMessage(from, buffer, image, {quoted: mek, caption: '*CRIADOR:* JOHN E BRAZ\n*YOUTUBE:* https://www.youtube.com/channel/UCFYtJ1tjEQzJPJ0Z22_N00Q\n*WPP:* wa.me/+5511941212232\n*INSTA BRAZ:* @@davi_rp04\n\n\nEspero que estejam amando o BOT ü•µ'})
					  client.sendMessage(from, 'Contato dos donos: Wa.me/5511941212232 Wa.me/5521980411540, por gentileza n√£o floodar',MessageType.text, { quoted: mek} )
                    break
					
					break
				case 'clearall':
					if (!isOwner) return reply('Quem √© Voc√™?')
					anu = await client.chats.all()
					client.setMaxListeners(25)
					for (let _ of anu) {
						client.deleteChat(_.jid)
					}
					reply('Sukses deletou todo o chat :)')
					break
				case 'bc':
					if (!isOwner) return reply('Quem √© voc√™?')
					if (args.length < 1) return reply('.......')
					anu = await client.chats.all()
					if (isMedia && !mek.message.videoMessage || isQuotedImage) {
						const encmedia = isQuotedImage ? JSON.parse(JSON.stringify(mek).replace('quotedM','m')).message.extendedTextMessage.contextInfo : mek
						buff = await client.downloadMediaMessage(encmedia)
						for (let _ of anu) {
							client.sendMessage(_.jid, buff, image, {caption: `[ TRANSMISS√ÉO DOS DONOS DO ùêÅùêéùêì ]\n\n${body.slice(4)}`})
						}
						reply('Mensagem enviada')
					} else {
						for (let _ of anu) {
							sendMess(_.jid, `[ TRANSMISS√ÉO DOS DONOS DO ùêÅùêéùêì ]\n\n${body.slice(4)}`)
						}
						reply('Mensagem enviada com sucesso')
					}
					break
case 'aviso':
					if (!isOwner) return reply('Quem √© voc√™?')
					if (args.length < 1) return reply('.......')
					anu = await client.chats.all()
					if (isMedia && !mek.message.videoMessage || isQuotedImage) {
						const encmedia = isQuotedImage ? JSON.parse(JSON.stringify(mek).replace('quotedM','m')).message.extendedTextMessage.contextInfo : mek
						buff = await client.downloadMediaMessage(encmedia)
						for (let _ of anu) {
							client.sendMessage(_.jid, buff, image, {caption: `[ AVISO IMPORTANTE DOS DONOS DO ùêÅùêéùêì ]\n\n${body.slice(4)}`})
						}
						reply('Mensagem enviada')
					} else {
						for (let _ of anu) {
							sendMess(_.jid, `[ AVISO IMPORTANTE DOS DONOS DO ùêÅùêéùêì ]\n\n${body.slice(4)}`)
						}
						reply('Mensagem enviada com sucesso')
					}
					break
case 'divulgar':
					if (!isOwner) return reply('Quem √© voc√™?')
					if (args.length < 1) return reply('.......')
					anu = await client.chats.all()
					if (isMedia && !mek.message.videoMessage || isQuotedImage) {
						const encmedia = isQuotedImage ? JSON.parse(JSON.stringify(mek).replace('quotedM','m')).message.extendedTextMessage.contextInfo : mek
						buff = await client.downloadMediaMessage(encmedia)
						for (let _ of anu) {
							client.sendMessage(_.jid, buff, image, {caption: `[ ATUALIZA√á√ÉO IMPORTANTE ]\n\n${body.slice(4)}`})
						}
						reply('Atualiza√ß√£o enviada')
					} else {
						for (let _ of anu) {
							sendMess(_.jid, `[ ATUALIZA√á√ÉO IMPORTANTE ]\n\n${body.slice(4)}`)
						}
						reply('Atualiza√ß√£o enviada com sucesso')
					}
					break
				case 'setprefix':
					if (args.length < 1) return
					if (!isOwner) return reply(mess.only.ownerB)
					prefix = args[0]
					setting.prefix = prefix
					fs.writeFileSync('./src/settings.json', JSON.stringify(setting, null, '\t'))
					reply(`Prefixo alterado com sucesso : ${prefix}`)
					break
                 //_RANKS E %
case '%gay':		
	            	if (args.length < 1) return reply('Marque todos os Gays do Grupo!')
					rate = body.slice(5)
					var ti =['4','9','17','28','34','48','59','62','74','83','97','100','29','94','75','82','41','39']
					var kl = ti[Math.floor(Math.random() * ti.length)]
					client.sendMessage(from, 'Como voc√™ √© Gay: *'+rate+'*\n\nSua porcentagem Gay : '+ kl+'%\n Esse ai ama d√° o c√∫', text, { quoted: mek })
					break
case '%feio':		
	            	if (args.length < 1) return reply('Marque alguem feio que doi!')
					rate = body.slice(6)
					var ti =['4','9','17','28','34','48','59','62','74','83','97','100','29','94','75','82','41','39']
					var kl = ti[Math.floor(Math.random() * ti.length)]
					client.sendMessage(from, 'Como voc√™ √© feio: *'+rate+'*\n\nSua porcentagem de feiura √© : '+ kl+'%\n Parece um sarigue kkk', text, { quoted: mek })
					break
case '%lindo':		
	            	if (args.length < 1) return reply('marque alguem bonito!')
					rate = body.slice(8)
					var ti =['4','9','17','28','34','48','59','62','74','83','97','100','29','94','75','82','41','39']
					var kl = ti[Math.floor(Math.random() * ti.length)]
					client.sendMessage(from, 'Como voc√™ √© lindo: *'+rate+'*\n\nSua porcentagem de Lindeza √© : '+ kl+'%\n Parece um boleto pago kkk', text, { quoted: mek })
					break
case '%gostoso':		
	            	if (args.length < 1) return reply('Marque sua m√£e aquela gostosa!')
					rate = body.slice(9)
					var ti =['4','9','17','28','34','48','59','62','74','83','97','100','29','94','75','82','41','39']
					var kl = ti[Math.floor(Math.random() * ti.length)]
					client.sendMessage(from, 'Tu e gostoso(a) ser√°?: *'+rate+'*\n\nSua porcentagem de gostoso √© : '+ kl+'%ü§§\n Slk viado, gostoso pra caralhoüåö kkk', text, { quoted: mek })
					break
case '%gado':		
	            	if (args.length < 1) return reply('marque um gado!')
					rate = body.slice(6)
					var ti =['4','9','17','28','34','48','59','62','74','83','97','100','29','94','75','82','41','39']
					var kl = ti[Math.floor(Math.random() * ti.length)]
					client.sendMessage(from, 'Tu e gado(a) ser√°?: *'+rate+'*\n\nSua porcentagem de gado √© : '+ kl+'%üòè\n Maluco falta furar um buraco na parede kkk', text, { quoted: mek })
					break
case 'rankcaco':
try{
if(!isGroup) return reply(mess.only.group)
if (!isGroupAdmins) return reply(mess.only.admin)
d = []
teks = 'üêí Rank dos Macacos\n'
for(i = 0; i < 5; i++) {
r = Math.floor(Math.random() * groupMetadata.participants.length + 0)
teks += `Ô∏è‚Äçüêí‚ùß @${groupMembers[r].jid.split('@')[0]}\n`
d.push(groupMembers[r].jid)
}
mentions(teks, d, true)
} catch (e) {
console.log(e)
reply('Deu erro infelizmente, tente novamente :/')
}
break
case 'rankgay':
try{
if(!isGroup) return reply(mess.only.group)
d = []
teks = 'üè≥Ô∏è‚Äçüåà Rank dos mais Gays\n'
for(i = 0; i < 5; i++) {
r = Math.floor(Math.random() * groupMetadata.participants.length + 0)
teks += `üè≥Ô∏è‚Äçüåà‚ùß @${groupMembers[r].jid.split('@')[0]}\n`
d.push(groupMembers[r].jid)
}
mentions(teks, d, true)
} catch (e) {
console.log(e)
reply('Deu erro infelizmente, tente novamente :/')
}
break
case 'ranklindos':
try{
if(!isGroup) return (mess.only.group)
d = []
teks = 'ü§©Rank dos mais lindos \n'
for(i = 0; i < 5; i++) {
r = Math.floor(Math.random() * groupMetadata.participants.length + 0)
teks += `ü§©‚ùß @${groupMembers[r].jid.split('@')[0]}\n`
d.push(groupMembers[r].jid)
}
mentions(teks, d, true)
} catch (e) {
console.log(e)
reply('Deu erro, tente novamente :/')
}
break
case 'ranknazista':
try{
if(!isGroup) return reply(mess.only.group)
d = []
teks = 'üíÇ‚Äç‚ôÇÔ∏èRank dos mais nazistas\n'
for(i = 0; i < 5; i++) {
r = Math.floor(Math.random() * groupMetadata.participants.length + 0)
teks += `üíÇ‚Äç‚ôÇÔ∏è‚ùß @${groupMembers[r].jid.split('@')[0]}\n`
d.push(groupMembers[r].jid)
}
mentions(teks, d, true)
} catch (e) {
console.log(e)
reply('Deu erro infelizmente, tente novamente :/')
}
break
case 'rankgostoso':
try{
if(!isGroup) return (mess.only.group)
d = []
teks = 'üòèRank dos mais gostosos\n'
for(i = 0; i < 5; i++) {
r = Math.floor(Math.random() * groupMetadata.participants.length + 0)
teks += `üòè‚ùß @${groupMembers[r].jid.split('@')[0]}\n`
d.push(groupMembers[r].jid)
}
mentions(teks, d, true)
} catch (e) {
console.log(e)
reply('Deu erro infelizmente, tente novamente :/')
}
break
case 'rankgado':
try{
if(!isGroup) return (mess.only.group)
d = []
teks = 'üêÉRank dos mais gados\n'
for(i = 0; i < 5; i++) {
r = Math.floor(Math.random() * groupMetadata.participants.length + 0)
teks += `üêÉ‚ùß @${groupMembers[r].jid.split('@')[0]}\n`
d.push(groupMembers[r].jid)
}
mentions(teks, d, true)
} catch (e) {
console.log(e)
reply('Deu erro infelizmente, tente novamente :/')
}
break
case 'rankfeios':
try{
if(!isGroup) return (mess.only.group)
d = []
teks = '"ü§ìRank dos mais feios \n'
for(i = 0; i < 5; i++) {
r = Math.floor(Math.random() * groupMetadata.participants.length + 0)
teks += `ü§ì‚ùß @${groupMembers[r].jid.split('@')[0]}\n`
d.push(groupMembers[r].jid)
}
mentions(teks, d, true)
} catch (e) {
console.log(e)
reply('Deu erro infelizmente, tente novamente :/')
}
break
case 'cassino':
const cassino = ['„Ö§\n*‚ïî‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*\n*‚ïë*\n*‚ïë*\n*‚ï†* ROLETA DOS TR√äS\n*‚ï†* N√öMEROS\n*‚ïë*\n*‚ï†‚ïê‚îÄ 1 ‚îÄ‚ïê‚îÄ 2 ‚îÄ‚ïê‚îÄ 3*\n*‚ïë*\n*‚ïë*\n*‚ï†* N√£o foi dessa vez mas\n*‚ïë* continue tentando.\n*‚ïë*\n*‚ïö‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*','„Ö§\n*‚ïî‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*\n*‚ïë*\n*‚ïë*\n*‚ï†* ROLETA DOS TR√äS\n*‚ï†* N√öMEROS\n*‚ïë*\n*‚ï†‚ïê‚îÄ 2 ‚îÄ‚ïê‚îÄ 3 ‚îÄ‚ïê‚îÄ 1*\n*‚ïë*\n*‚ïë*\n*‚ï†* N√£o foi dessa vez mas\n*‚ïë* continue tentando.\n*‚ïë*\n*‚ïö‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*','„Ö§\n*‚ïî‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*\n*‚ïë*\n*‚ïë*\n*‚ï†* ROLETA DOS TR√äS\n*‚ï†* N√öMEROS\n*‚ïë*\n*‚ï†‚ïê‚îÄ 3 ‚îÄ‚ïê‚îÄ 2 ‚îÄ‚ïê‚îÄ 1*\n*‚ïë*\n*‚ïë*\n*‚ï†* N√£o foi dessa vez mas\n*‚ïë* continue tentando.\n*‚ïë*\n*‚ïö‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*','„Ö§\n*‚ïî‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*\n*‚ïë*\n*‚ïë*\n*‚ï†* ROLETA DOS TR√äS\n*‚ï†* N√öMEROS\n*‚ïë*\n*‚ï†‚ïê‚îÄ 1 ‚îÄ‚ïê‚îÄ 3 ‚îÄ‚ïê‚îÄ 2*\n*‚ïë*\n*‚ïë*\n*‚ï†* N√£o foi dessa vez mas\n*‚ïë* continue tentando.\n*‚ïë*\n*‚ïö‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*','„Ö§\n*‚ïî‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*\n*‚ïë*\n*‚ïë*\n*‚ï†* ROLETA DOS TR√äS\n*‚ï†* N√öMEROS\n*‚ïë*\n*‚ï†‚ïê‚îÄ 2 ‚îÄ‚ïê‚îÄ 1 ‚îÄ‚ïê‚îÄ 3*\n*‚ïë*\n*‚ïë*\n*‚ï†* N√£o foi dessa vez mas\n*‚ïë* continue tentando.\n*‚ïë*\n*‚ïö‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*','„Ö§\n*‚ïî‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*\n*‚ïë*\n*‚ïë*\n*‚ï†* ROLETA DOS TR√äS\n*‚ï†* N√öMEROS\n*‚ïë*\n*‚ï†‚ïê‚îÄ 3 ‚îÄ‚ïê‚îÄ 1 ‚îÄ‚ïê‚îÄ 2*\n*‚ïë*\n*‚ïë*\n*‚ï†* N√£o foi dessa vez mas\n*‚ïë* continue tentando.\n*‚ïë*\n*‚ïö‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*','„Ö§\n*‚ïî‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*\n*‚ïë*\n*‚ïë*\n*‚ï†* ROLETA DOS TR√äS\n*‚ï†* N√öMEROS\n*‚ïë*\n*‚ï†‚ïê‚îÄ 1 ‚îÄ‚ïê‚îÄ 1 ‚îÄ‚ïê‚îÄ 1*\n*‚ïë*\n*‚ïë*\n*‚ï†* PARAB√âNS !!!\n*‚ï†* VOC√ä GANHOU NO CASSINO.\n*‚ïë*\n*‚ïö‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*','„Ö§\n*‚ïî‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*\n*‚ïë*\n*‚ïë*\n*‚ï†* ROLETA DOS TR√äS\n*‚ï†* N√öMEROS\n*‚ïë*\n*‚ï†‚ïê‚îÄ 2 ‚îÄ‚ïê‚îÄ 2 ‚îÄ‚ïê‚îÄ 2*\n*‚ïë*\n*‚ïë*\n*‚ï†* PARAB√âNS !!!\n*‚ï†* VOC√ä GANHOU NO CASSINO.\n*‚ïë*\n*‚ïö‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*','„Ö§\n*‚ïî‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*\n*‚ïë*\n*‚ïë*\n*‚ï†* ROLETA DOS TR√äS\n*‚ï†* N√öMEROS\n*‚ïë*\n*‚ï†‚ïê‚îÄ 3 ‚îÄ‚ïê‚îÄ 3 ‚îÄ‚ïê‚îÄ 3*\n*‚ïë*\n*‚ïë*\n*‚ï†* PARAB√âNS !!!\n*‚ï†* VOC√ä GANHOU NO CASSINO.\n*‚ïë*\n*‚ïö‚ïê‚îÄ CASSINO ‚îÄ‚ïê‚ïê*']
					random = cassino[Math.floor(Math.random() * (cassino.length))]
					reply(`${random}`)
					break
case 'cassino2':
if (!isPremium) return reply ("Voc√™ precisa ser Vip para ter essa fun√ß√£o")
		const sotoy = [
		'üçä : üçí : üçê',
		'üçí : üîî : üçä',
		'üçá : üçá : üçá',
		'üçä : üçã : üîî',
		'üîî : üçí : üçê',
		'üîî : üçí : üçä',
        'üçä : üçã : üîî',		
		'üçê : üçí : üçã',
		'üçê : üçê : üçê',
		'üçä : üçí : üçí',
		'üîî : üîî : üçá',
		'üçå : üçí : üîî',
		'üçê : üîî : üîî',
		'üçä : üçã : üçí',
		'üçã : üçã : üçå',
		'üîî : üîî : üçá',
		'üîî : üçê : üçá',
		'üîî : üîî : üîî',
		'üçí : üçí : üçí',
		'üçå : üçå : üçå'
		]
            const somtoy = sotoy[Math.floor(Math.random() * sotoy.length)]
	yow = `[  üé∞ | SLOTS ]\n-----------------\nüçã : üçå : üçç\n${somtoy}<=====\nüçã : üçå : üçç\n[  üé∞ | SLOTS ]\n\nInforma√ßoes : Se voc√™ pegar 3 iguais significa que voc√™ ganhou\n\nExemplo : üçå : üçå : üçå<=====`
            reply(yow)
	            break
case 'pombinhos':
case 'casal':
					if (!isGroup) return reply(mess.only.group)
						membr = []
						const suamae11 = groupMembers
						const suamae21 = groupMembers
						const teupai11 = suamae11[Math.floor(Math.random() * suamae11.length)]
						const teupai21 = suamae21[Math.floor(Math.random() * suamae21.length)]
						var shipted1 = ["1%", `10%`, `20%`, `40%`, `50%`, `60%`, `80%`, `90%`, `100%`, `99999%`]
						const shipted = shipted1[Math.floor(Math.random() * shipted1.length)]
						teks = `*Hmmm.... Shippo os dois üíüüíü*\n\n1= @${teupai11.jid.split('@')[0]}\ne esse\n2= @${teupai21.jid.split('@')[0]}\ncom uma porcentagem de: ${shipted}`
						membr.push(teupai11.jid)
						membr.push(teupai21.jid)
						mentions(teks, membr, true)
					break
					case 'gostosas':
      if (!isGroup) return reply(mess.only.group)
                        member = []
                        const p1 = groupMembers
                        const p2 = groupMembers
                        const p3 = groupMembers
                        const p4 = groupMembers
                        const p5 = groupMembers
                        const o1 = p1[Math.floor(Math.random() * p1.length)]
                        const o2 = p2[Math.floor(Math.random() * p2.length)]
                        const o3 = p3[Math.floor(Math.random() * p3.length)]
                        const o4 = p4[Math.floor(Math.random() * p4.length)]
                        const o5 = p5[Math.floor(Math.random() * p5.length)]
                        teks = `
                  Paradas!ü§öü§ö\n\n1=ü§öü§≠@${o1.jid.split('@')[0]}ü§öü§≠\n\n\n2=ü§öü§≠@${o2.jid.split('@')[0]}ü§öü§≠\n\n\n3=ü§öü§≠@${o3.jid.split('@')[0]}ü§öü§≠\n\n\n4=ü§öü§≠@${o4.jid.split('@')[0]}ü§öü§≠\n\n\n5=ü§öü§≠@${o5.jid.split('@')[0]}ü§öü§≠\n\n\nMultas por serem gostosas dmsüò≥ pague pena enviando nud no PV do donoüòä by Bot`
                        member.push(o1.jid)
                        member.push(o2.jid)
                        member.push(o3.jid)
                        member.push(o4.jid)
                        member.push(o5.jid)
                        mentions(teks, member, true)
                                        break 
				//_GRUPOS
				case 'hidetag':
					if (!isGroup) return reply(mess.only.group)
					if (!isOwner) return reply(mess.only.ownerB)
					var value = body.slice(9)
					var group = await client.groupMetadata(from)
					var member = group['participants']
					var mem = []
					member.map( async adm => {
					mem.push(adm.id.replace('c.us', 's.whatsapp.net'))
					})
					var options = {
					text: value,
					contextInfo: { mentionedJid: mem },
					quoted: mek
					}
					client.sendMessage(from, options, text)
					break
				case 'fotogp':
                    if (!isGroup) return reply(mess.only.group)
                    if (!isBotGroupAdmins) return reply(mess.only.Badmin)
                    media = await client.downloadAndSaveMediaMessage(mek)
                    await client.updateProfilePicture (from, media)
                    reply('Alterado com sucesso o √≠cone do Grupo')
                    break
				case 'banir':
					if (!isGroup) return reply(mess.only.group)
					if (!isGroupAdmins) return reply(mess.only.admin)
					if (!isBotGroupAdmins) return reply(mess.only.Badmin)
					if (mek.message.extendedTextMessage === undefined || mek.message.extendedTextMessage === null) return reply('A marca-alvo que voc√™ quer chutar!')
					mentioned = mek.message.extendedTextMessage.contextInfo.mentionedJid
					if (mentioned.length > 1) {
						teks = 'Alvo removido com sucesso :\n'
						for (let _ of mentioned) {
							teks += `@${_.split('@')[0]}\n`
						}
						mentions(teks, mentioned, true)
						client.groupRemove(from, mentioned)
					} else {
						mentions(`Alvo removido com sucesso  : @${mentioned[0].split('@')[0]}`, mentioned, true)
						client.groupRemove(from, mentioned)
					}
					break
				
					case 'ytmp4':
						if (args.length < 1) return reply('Cad√™ o url, hum?')
						if(!isUrl(args[0]) && !args[0].includes('youtu')) return reply(mess.error.Iv)
						anu = await fetchJson(`https://st4rz.herokuapp.com/api/ytv2?url=${args[0]}`, {method: 'get'})
						if (anu.error) return reply(anu.error)
						teks = `*T√≠tulo* : ${anu.title}`
						thumb = await getBuffer(anu.thumb)
						client.sendMessage(from, thumb, image, {quoted: mek, caption: teks})
						buffer = await getBuffer(anu.result)
						client.sendMessage(from, buffer, video, {mimetype: 'video/mp4', filename: `${anu.title}.mp4`, quoted: mek})
						break
						
						case 'play':
						if (args.length == 0) return reply(`Use o comando assim: .play nome_da_msc`)
						query = args.join(" ")
						get_result = await fetchJson(`http://api.lolhuman.xyz/api/ytplay?apikey=c16d73b5bb6192a0a50aad04&query=${query}`)
						get_result = get_result.result
						get_info = get_result.info
						desc = `
üé∂ T√≠tulo: ${get_info.title}

üì¢ Upado por: ${get_info.uploader}
						
üïì Dura√ß√£o: ${get_info.duration}
						
„ÄΩÔ∏è Visualiza√ß√µes: ${get_info.view}
						
üëçüèª Like: ${get_info.like}
						
üëéüèª Dislike: ${get_info.dislike}

‚ö†Ô∏è Tamanho do audio: ${get_result.audio[3].size}

üî± Taxa de bits: ${get_result.audio[3].bitrate}
						
‚úÖ Descri√ß√£o: ${get_info.description}


Estou enviando o audio aguarde`
						ini_buffer = await getBuffer(get_info.thumbnail)
						client.sendMessage(from, ini_buffer, image, { quoted: mek, caption: desc })
					reply('üîä Coletando inform√ß√µes e enviando a musica/audio.')
						get_audio = await getBuffer(get_result.audio[3].link)
						client.sendMessage(from, get_audio, audio, { mimetype: 'audio/mp4', filename: `${get_info.title}.mp3`, quoted: mek})
						break


case 'covid19':
post = await fetchJson(`https://api-gdr2.herokuapp.com/api/covidbr`)
send = `ùêãùêéùêÇùêÄùêã: ${post.result.local}\nùêÉùêÄùêÉùêéùêí: ${post.result.dadosAtualizados}\nùêìùêéùêìùêÄùêã ùêÉùêÑ ùêÇùêÄùêíùêéùêí: ${post.result.totalCasos}\nùêçùêéùêïùêéùêí ùêÇùêÄùêíùêéùêí: ${post.result.novosCasos}\nùêìùêéùêìùêÄùêã ùêÉùêÑ ùêåùêéùêëùêìùêÑùêí: ${post.result.totalMortes}\nùêçùêéùêïùêÄùêí ùêåùêéùêëùêìùêÑùêí: ${post.result.novasMortes}\nùêëùêÑùêÇùêîùêèùêÑùêëùêÄùêÉùêéùêí: ${post.result.recuperados}\n 
ùêïùêÄùêÇùêàùêçùêÄùêÉùêéùêí-1: ${post.result.vacinadosPrimeiraDose}\nùêïùêÄùêÇ??ùêçùêÄùêÉùêéùêí-2: ${post.result.vacinadosSegundaDose}\nùêÅùêéùêãùêÑùêìùêàùêçùêí: ${post.result.boletinsContabilizados}`
client.sendMessage(from, send, text, {quoted: { key: { fromMe: false, participant: `0@s.whatsapp.net`, ...(from ? { remoteJid: "status@broadcast" } : {}) }, message: { "imageMessage": { "url": "https://mmg.whatsapp.net/d/f/At0x7ZdIvuicfjlf9oWS6A3AR9XPh0P-hZIVPLsI70nM.enc", "mimetype": "image/jpeg", "caption": "ùêïùêûùê´ùê¢ùêüùê¢ùêúùêöùêùùê® ùê©ùê®ùê´ ùêñùê°ùêöùê≠ùê¨ùêöùê©ùê©\nEstatisticas Covid-19 Br", "fileSha256": "+Ia+Dwib70Y1CWRMAP9QLJKjIJt54fKycOfB2OEZbTU=", "fileLength": "28777", "height": 1080, "width": 1079, "mediaKey": "vXmRR7ZUeDWjXy5iQk17TrowBzuwRya0errAFnXxbGc=", "fileEncSha256": "sR9D2RS5JSifw49HeBADguI23fWDz1aZu4faWG/CyRY=", "directPath": "/v/t62.7118-24/21427642_840952686474581_572788076332761430_n.enc?oh=3f57c1ba2fcab95f2c0bb475d72720ba&oe=602F3D69", "mediaKeyTimestamp": "1610993486", "jpegThumbnail": fs.readFileSync('./assets/botlogo.webp')} } }, caption: "<//>" })
break
				case 'abra√ßo':
if (!isGroup) return reply(mess.only.group)
if (mek.message.extendedTextMessage === undefined || mek.message.extendedTextMessage === null) return 
mentioned = mek.message.extendedTextMessage.contextInfo.mentionedJid
pro = '.\n'
for (let _ of mentioned) {
pro += `@${_.split('@')[0]}\n`
}
yhb = `Que fofo... @${sender.split("@")[0]} deu um abra√ßo apertado em @${mentioned[0].split('@')[0]}`
mentions(yhb, yhb, true)
break
				case 'linkgp':
                    if (!isGroup) return reply(mess.only.group)
                    if (!isGroupAdmins) return reply(mess.only.admin)
                    if (!isBotGroupAdmins) return reply(mess.only.Badmin)
                    linkgc = await client.groupInviteCode(from)
                    reply('https://chat.whatsapp.com/'+linkgc)
                    break
                case 'sair':
                    if (!isGroup) return reply(mess.only.group)
                    if (isGroupAdmins || isOwner) {
                    	client.groupLeave(from)
                    } else {
                        reply(mess.only.admin)
                    }
                    break
				case 'marcar':
					if (!isGroup) return reply(mess.only.group)
					if (!isGroupAdmins) return reply(mess.only.admin)
					members_id = []
					teks = (args.length > 1) ? body.slice(8).trim() : ''
					teks += '\n\n'
					for (let mem of groupMembers) {
						teks += `*#* @${mem.jid.split('@')[0]}\n`
						members_id.push(mem.jid)
					}
					mentions(teks, members_id, true)
					break
                                case 'marcar2':
					members_id = []
					teks = (args.length > 1) ? body.slice(8).trim() : ''
					teks += '\n\n'
					for (let mem of groupMembers) {
						teks += `‚ï†‚û• @${mem.jid.split('@')[0]}\n`
						members_id.push(mem.jid)
					}
					reply(teks)
					break
				case 'marcar3':
					members_id = []
					teks = (args.length > 1) ? body.slice(8).trim() : ''
					teks += '\n\n'
					for (let mem of groupMembers) {
						teks += `‚ï†‚û• https://wa.me/${mem.jid.split('@')[0]}\n`
						members_id.push(mem.jid)
					}
					client.sendMessage(from, teks, text, {detectLinks: false, quoted: mek})
					break
case 'rr':
                    rate = body.slice(1)
                    ratee = ["Tac... N√£o disparou","Tac... N√£o disparou,ainda...","Tacüí• Disparou e voc√™ morreu","Tacüí•Disparou mas a bala pegou de rasp√£o","A arma falhou","Tac... Por pouco que n√£o dispara...","Tac... A arma estava descarregada"]
                    const cu = ratee[Math.floor(Math.random() * ratee.length)]
                    client.sendMessage(from, ''+ cu+'', text, { quoted: mek })
                    break
case 'plaquinha':
					if (args.length < 1) return reply(mess.blank)
					teks = body.slice(11)
					if (teks.length > 25) return reply('O texto √© longo, at√© 25 caracteres')
					reply('*Estou fazendo, se der erro tente novamente ‚úì*')
					buffer = await getBuffer(`https://ubbornag.sirv.com/Screenshot_20210513-151821.png?text.0.text=${teks}&text.0.position.x=-40%25&text.0.position.y=-65%25&text.0.size=30&text.0.color=000000&text.0.opacity=53&text.0.font.family=Shadows%20Into%20Light%20Two&text.0.outline.blur=15`)
					client.sendMessage(from, buffer, image, {quoted: mek, caption: 'Ta na m√£o üòà'})
					break
case 'qrcode':
        			if (!isPremium) return reply('Voc√™ n√£o √© um Membro Premium, entre em contato com o propriet√°rio para adquirir o acesso Premium!' ,text, { quoted: mek })
					const tex = encodeURIComponent(body.slice(8))
					if (!tex) return client.sendMessage(from, 'Digite um texto/url que deseja criar um c√≥digo qr', text, {quoted: mek})
					const bufferr = await getBuffer(`https://api.qrserver.com/v1/create-qr-code/?size=500x500&data=${tex}`)
					client.sendMessage(from, bufferr, image, {quoted: mek})
					break
				//_FIGURINHAS
				case 'attp' :
				case 'sttp' :
					if (args.length < 1) return reply(`ERROR: Cade o texto?? \nUso: ${prefix}attp (seu texto aqui)`)
					try {
						var chollotxt = body.slice(5).trim()
						reply(mess.wait)
						url = encodeURI(`https://api.xteam.xyz/attp?file&text=${chollotxt}`)
						textofigu = await getBuffer(url)
						client.sendMessage(from, textofigu, sticker, { quoted: mek })
					}
					
					
					catch (e) {
						reply("Error: Use apenas caracteres alfanum√©ricos")
					}
					break
case 'ttp':
if (args.length < 1) return reply(`Use dessa forma:\nComando: ${prefix}ttp Toin gado`)
attp2 = await getBuffer(`https://api.xteam.xyz/ttp?file&text=${encodeURIComponent(body.slice(4))}`)
client.sendMessage(from, attp2, sticker, {quoted: mek})
break
				case 'stiker':
				case 'sticker':
			    case 'f':
			    case 'figu':
			     case 'fig':
					if ((isMedia && !mek.message.videoMessage || isQuotedImage) && args.length == 0) {
						const encmedia = isQuotedImage ? JSON.parse(JSON.stringify(mek).replace('quotedM','m')).message.extendedTextMessage.contextInfo : mek
						const media = await client.downloadAndSaveMediaMessage(encmedia)
						ran = getRandom('.webp')
						await ffmpeg(`./${media}`)
							.input(media)
							.on('start', function (cmd) {
								console.log(`Started : ${cmd}`)
							})
							.on('error', function (err) {
								console.log(`Error : ${err}`)
								fs.unlinkSync(media)
								reply(mess.error.stick)
							})
							.on('end', function () {
								console.log('Finish')
								client.sendMessage(from, fs.readFileSync(ran), sticker, {quoted: mek})
								fs.unlinkSync(media)
								fs.unlinkSync(ran)
							})
							.addOutputOptions([`-vcodec`,`libwebp`,`-vf`,`scale='min(320,iw)':min'(320,ih)':force_original_aspect_ratio=decrease,fps=15, pad=320:320:-1:-1:color=white@0.0, split [a][b]; [a] palettegen=reserve_transparent=on:transparency_color=ffffff [p]; [b][p] paletteuse`])
							.toFormat('webp')
							.save(ran)
					} else if ((isMedia && mek.message.videoMessage.seconds < 11 || isQuotedVideo && mek.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage.seconds < 11) && args.length == 0) {
						const encmedia = isQuotedVideo ? JSON.parse(JSON.stringify(mek).replace('quotedM','m')).message.extendedTextMessage.contextInfo : mek
						const media = await client.downloadAndSaveMediaMessage(encmedia)
						ran = getRandom('.webp')
						reply(mess.wait)
						await ffmpeg(`./${media}`)
							.inputFormat(media.split('.')[1])
							.on('start', function (cmd) {
								console.log(`Started : ${cmd}`)
							})
							.on('error', function (err) {
								console.log(`Error : ${err}`)
								fs.unlinkSync(media)
								tipe = media.endsWith('.mp4') ? 'video' : 'gif'
								reply(`‚ùå Falha ao converter ${tipe} para figurinha`)
							})
							.on('end', function () {
								console.log('Finish')
								client.sendMessage(from, fs.readFileSync(ran), sticker, {quoted: mek})
								fs.unlinkSync(media)
								fs.unlinkSync(ran)
							})
							.addOutputOptions([`-vcodec`,`libwebp`,`-vf`,`scale='min(320,iw)':min'(320,ih)':force_original_aspect_ratio=decrease,fps=15, pad=320:320:-1:-1:color=white@0.0, split [a][b]; [a] palettegen=reserve_transparent=on:transparency_color=ffffff [p]; [b][p] paletteuse`])
							.toFormat('webp')
							.save(ran)
					} else if ((isMedia || isQuotedImage) && args[0] == 'nobg') {
						const encmedia = isQuotedImage ? JSON.parse(JSON.stringify(mek).replace('quotedM','m')).message.extendedTextMessage.contextInfo : mek
						const media = await client.downloadAndSaveMediaMessage(encmedia)
						ranw = getRandom('.webp')
						ranp = getRandom('.png')
						reply(mess.wait)
						keyrmbg = 'Your-ApiKey'
						await removeBackgroundFromImageFile({path: media, apiKey: keyrmbg.result, size: 'auto', type: 'auto', ranp}).then(res => {
							fs.unlinkSync(media)
							let buffer = Buffer.from(res.base64img, 'base64')
							fs.writeFileSync(ranp, buffer, (err) => {
								if (err) return reply('Falha, ocorreu um erro, tente novamente mais tarde.')
							})
							exec(`ffmpeg -i ${ranp} -vcodec libwebp -filter:v fps=fps=20 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 512:512 ${ranw}`, (err) => {
								fs.unlinkSync(ranp)
								if (err) return reply(mess.error.stick)
								client.sendMessage(from, fs.readFileSync(ranw), sticker, {quoted: mek})
							})
						})
					/*} else if ((isMedia || isQuotedImage) && colors.includes(args[0])) {
						const encmedia = isQuotedImage ? JSON.parse(JSON.stringify(mek).replace('quotedM','m')).message.extendedTextMessage.contextInfo : mek
						const media = await client.downloadAndSaveMediaMessage(encmedia)
						ran = getRandom('.webp')
						await ffmpeg(`./${media}`)
							.on('start', function (cmd) {
								console.log('Started :', cmd)
							})
							.on('error', function (err) {
								fs.unlinkSync(media)
								console.log('Error :', err)
							})
							.on('end', function () {
								console.log('Finish')
								fs.unlinkSync(media)
								client.sendMessage(from, fs.readFileSync(ran), sticker, {quoted: mek})
								fs.unlinkSync(ran)
							})
							.addOutputOptions([`-vcodec`,`libwebp`,`-vf`,`scale='min(320,iw)':min'(320,ih)':force_original_aspect_ratio=decrease,fps=15, pad=320:320:-1:-1:color=${args[0]}@0.0, split [a][b]; [a] palettegen=reserve_transparent=off; [b][p] paletteuse`])
							.toFormat('webp')
							.save(ran)*/
					} else {
						reply(`Envie fotos com legendas ${prefix}sticker ou tags de imagem que j√° foram enviadas/Upload photos with ${prefix}sticker or image tags that have already been uploaded`)
					}
					break
				//_UTILIZAVEIS
case 'contar':
if (args.length == 0) return reply( '0 caracteres, pois obviamente n√£o h√° textoüòÄ')
const count = body.slice(8).length
if (count === 1) {
reply(`O texto possui ${count} caractere.`)
} else if (count > 1) {
reply(`O texto possui ${count} caracteres.`)
}
break
				case 'gay':
				rate = body.slice(5)
client.updatePresence(from, Presence.composing) 
random = `${Math.floor(Math.random() * 100)}`
boiola = random
if (boiola < 20 ) {bo = 'hmm... voc√™ √© heteroüòî'} else if (boiola == 21 ) {bo = '+/- boiola'} else if (boiola == 23 ) {bo = '+/- boiola'} else if (boiola == 24 ) {bo = '+/- boiola'} else if (boiola == 25 ) {bo = '+/- boiola'} else if (boiola == 26 ) {bo = '+/- boiola'} else if (boiola == 27 ) {bo = '+/- boiola'} else if (boiola == 28 ) {bo = '+/- boiola'} else if (boiola == 29 ) {bo = '+/- boiola'} else if (boiola == 30 ) {bo = '+/- boiola'} else if (boiola == 31 ) {bo = 'tenho minha desconfian√ßa...üòë'} else if (boiola == 32 ) {bo = 'tenho minha desconfian√ßa...üòë'} else if (boiola == 33 ) {bo = 'tenho minha desconfian√ßa...üòë'} else if (boiola == 34 ) {bo = 'tenho minha desconfian√ßa...üòë'} else if (boiola == 35 ) {bo = 'tenho minha desconfian√ßa...üòë'} else if (boiola == 36 ) {bo = 'tenho minha desconfian√ßa...üòë'} else if (boiola == 37 ) {bo = 'tenho minha desconfian√ßa...üòë'} else if (boiola == 38 ) {bo = 'tenho minha desconfian√ßa...üòë'} else if (boiola == 39 ) {bo = 'tenho minha desconfian√ßa...üòë'} else if (boiola == 40 ) {bo = 'tenho minha desconfian√ßa...üòë'} else if (boiola == 41 ) {bo = 'voc√™ √© n√©?üòè'} else if (boiola == 42 ) {bo = 'voc√™ √© n√©?üòè'} else if (boiola == 43 ) {bo = 'voc√™ √© n√©?üòè'} else if (boiola == 44 ) {bo = 'voc√™ √© n√©?üòè'} else if (boiola == 45 ) {bo = 'voc√™ √© n√©?üòè'} else if (boiola == 46 ) {bo = 'voc√™ √© n√©?üòè'} else if (boiola == 47 ) {bo = 'voc√™ √© n√©?üòè'} else if (boiola == 48 ) {bo = 'voc√™ √© n√©?üòè'} else if (boiola == 49 ) {bo = 'voc√™ √© n√©?üòè'} else if (boiola == 50 ) {bo = 'voc√™ √© ou n√£o?üßê'} else if (boiola > 51) {bo = 'voc√™ √© gayüôà'
}
hasil = `${rate} Voc√™ √© ${random}% gay\n\n${bo}`
reply(hasil)
break
case '%':
				algo = body.slice(2)
				pessoa = body.slice(1)
client.updatePresence(from, Presence.composing) 
random = `${Math.floor(Math.random() * 100)}`
porcentagem = random
if (porcentagem < 20 ) {frase = 'Voc√™ n√£o √©üòî'} else if (porcentagem == 21 ) {frase = '+/- ${algo}'} else if (porcentagem == 23 ) {frase = '+/- ${algo}'} else if (porcentagem == 24 ) {frase = '+/- ${algo}'} else if (porcentagem == 25 ) {frase = '+/- ${algo}'} else if (porcentagem == 26 ) {frase = '+/- ${algo}'} else if (porcentagem == 27 ) {frase = '+/- ${algo}'} else if (porcentagem == 28 ) {frase = '+/- ${algo}'} else if (porcentagem == 29 ) {frase = '+/- ${algo}'} else if (porcentagem == 30 ) {frase = '+/- ${algo}'} else if (porcentagem == 31 ) {frase = 'Talvez seja em...üòë'} else if (porcentagem == 32 ) {frase = 'Talvez seja em...üòë'} else if (porcentagem == 33 ) {frase = 'Talvez seja em...üòë'} else if (porcentagem == 34 ) {frase = 'Talvez seja em...üòë'} else if (porcentagem == 35 ) {frase = 'Talvez seja em...üòë'} else if (porcentagem == 36 ) {frase = 'Talvez seja em...üòë'} else if (porcentagem == 37 ) {frase = 'Talvez seja em...üòë'} else if (porcentagem == 38 ) {frase = 'Talvez seja em...üòë'} else if (porcentagem == 39 ) {frase = 'Talvez seja em...üòë'} else if (porcentagem == 40 ) {frase = 'Talvez seja em...üòë'} else if (porcentagem == 41 ) {frase = '√â sim em...'} else if (porcentagem == 42 ) {frase = '√â sim em...'} else if (porcentagem == 43 ) {frase = '√â sim em...'} else if (porcentagem == 44 ) {frase = '√â sim em...'} else if (porcentagem == 45 ) {frase = '√â sim em...'} else if (porcentagem == 46 ) {frase = '√â sim em...'} else if (porcentagem == 47 ) {frase = '√â sim em...'} else if (porcentagem == 48 ) {frase = '√â sim em...'} else if (porcentagem == 49 ) {frase = '√â sim em...'} else if (porcentagem == 50 ) {frase = '50% agora pra saber s√≥ ele dizendoüßê'} else if (porcentagem > 51) {frase = 'voc√™ √© concertezaüôà'
}
result = `${pessoa} Voc√™ √© ${random}% ${algo}\n\n${frase}`
reply(result)
break
				case 'cep':
if (args.length < 1) return reply('Digite o cep que deseja buscar')
cep = body.slice(4)
hehe = await fetchJson(`https://brasilapi.com.br/api/cep/v1/${cep}`)
if (hehe.error) return reply(hehe.error)
ccg =
` INFORMA√á√ïES DO CEP
  ‚Ä£ Cep: ${hehe.cep}
  ‚Ä£ Estado: ${hehe.state}
  ‚Ä£ Cidade: ${hehe.city}`
client.sendMessage(from, ccg, text, {quoted:mek})
break

				case 'img':
case 'image':
case 'imagem':
if (args.length < 1) return reply('Digite o comando juntamente com o que voc√™ deseja buscar')
client.updatePresence(from, Presence.composing)
reply(mess.wait)
try {
data = await fetchJson(`https://api.fdci.se/sosmed/rep.php?gambar=${args}`, {method: 'get'})
n = JSON.parse(JSON.stringify(data));
nimek = n[Math.floor(Math.random() * n.length)];
pok = await getBuffer(nimek)
client.sendMessage(from, pok, image, {quoted: mek, caption: `Achei isso sobre: ${args}`})
} catch {
reply(`N√£o econtrei nada sobre ${agrs}...`)
}
break
				case 'ler':
					if ((isMedia && !mek.message.videoMessage || isQuotedImage) && args.length == 0) {
						const encmedia = isQuotedImage ? JSON.parse(JSON.stringify(mek).replace('quotedM','m')).message.extendedTextMessage.contextInfo : mek
						const media = await client.downloadAndSaveMediaMessage(encmedia)
						reply(mess.wait)
						await recognize(media, {lang: 'eng+ind', oem: 1, psm: 3})
							.then(teks => {
								reply(teks.trim())
								fs.unlinkSync(media)
							})
							.catch(err => {
								reply(err.message)
								fs.unlinkSync(media)
							})
					} else {
						reply('S√≥ uma foto mano')
					}
					break
//_COMANDOS DE AUDIO

				//_EFEITO NIGHTCORE PARA AUDIO         
case 'nightcore':
encmedia = JSON.parse(JSON.stringify(mek).replace('quotedM','m')).message.extendedTextMessage.contextInfo
media = await client.downloadAndSaveMediaMessage(encmedia)
ran = getRandom('.mp3')
exec(`ffmpeg -i ${media} -filter:a atempo=1.06,asetrate=44100*1.25 ${ran}`, (err, stderr, stdout) => {
fs.unlinkSync(media)
if (err) return reply('Error!')
hah = fs.readFileSync(ran)
client.sendMessage(from, hah, audio, {mimetype: 'audio/mp4', ptt:true, quoted: mek})
fs.unlinkSync(ran)
})
break   

//_EFEITO SLOW PARA AUDIO
case 'slow':
low = JSON.parse(JSON.stringify(mek).replace('quotedM','m')).message.extendedTextMessage.contextInfo
slo = await client.downloadAndSaveMediaMessage(low)
ran = getRandom('.mp3')
exec(`ffmpeg -i ${slo} -filter:a "atempo=0.9,asetrate=44100" ${ran}`, (err, stderr, stdout) => {
fs.unlinkSync(slo)
if (err) return reply('Error!')
hah = fs.readFileSync(ran)
client.sendMessage(from, hah, audio, {mimetype: 'audio/mp4', ptt:true, quoted: mek})
fs.unlinkSync(ran)
})
break

//_EFEITO ESQUILO PARA AUDIO
case 'esquilo':
pai = JSON.parse(JSON.stringify(mek).replace('quotedM','m')).message.extendedTextMessage.contextInfo
tup = await client.downloadAndSaveMediaMessage(pai)
ran = getRandom('.mp3')
exec(`ffmpeg -i ${tup} -filter:a "atempo=0.7,asetrate=65100" ${ran}`, (err, stderr, stdout) => {
fs.unlinkSync(tup)
if (err) return reply('Error!')
hah = fs.readFileSync(ran)
client.sendMessage(from, hah, audio, {mimetype: 'audio/mp4', ptt:true, quoted: mek})
fs.unlinkSync(ran)
})
break

//_EFEITO GIGANTE PARA AUDIO	
case 'gemuk':
muk = JSON.parse(JSON.stringify(mek).replace('quotedM','m')).message.extendedTextMessage.contextInfo
gem = await client.downloadAndSaveMediaMessage(muk)
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a "atempo=1.6,asetrate=22100" ${ran}`, (err, stderr, stdout) => {
fs.unlinkSync(gem)
if (err) return reply('Error!')
hah = fs.readFileSync(ran)
client.sendMessage(from, hah, audio, {mimetype: 'audio/mp4', ptt:true, quoted: mek})
fs.unlinkSync(ran)
})
break

//_DEIXA O AUDIO R√ÅPIDO
case 'fast':
encmedia = JSON.parse(JSON.stringify(mek).replace('quotedM','m')).message.extendedTextMessage.contextInfo
media = await client.downloadAndSaveMediaMessage(encmedia)
ran = getRandom('.mp3')
exec(`ffmpeg -i ${media} -filter:a "atempo=0.9,asetrate=95100" ${ran}`, (err, stderr, stdout) => {
fs.unlinkSync(media)
if (err) return reply('Erro')
hah = fs.readFileSync(ran)
client.sendMessage(from, hah, audio, {mimetype: 'audio/mp4', ptt:true, quoted: mek})
fs.unlinkSync(ran)
})
break

//_AUMENTA O BASS DE UM AUDIO	
case 'bass':                 
ass = JSON.parse(JSON.stringify(mek).replace('quotedM','m')).message.extendedTextMessage.contextInfo
bas = await client.downloadAndSaveMediaMessage(ass)
ran = getRandom('.mp3')
exec(`ffmpeg -i ${bas} -af equalizer=f=70:width_type=o:width=2:g=15 ${ran}`, (err, stderr, stdout) => {
fs.unlinkSync(bas)
if (err) return reply('Error!')
hah = fs.readFileSync(ran)
client.sendMessage(from, hah, audio, {mimetype: 'audio/mp4', ptt:true, quoted: mek})
fs.unlinkSync(ran)
})
break

//_DEIXA O AUDIO ESTOURADO		
case 'earrape':         
case 'estourar':       
ass = JSON.parse(JSON.stringify(mek).replace('quotedM','m')).message.extendedTextMessage.contextInfo
bas = await client.downloadAndSaveMediaMessage(ass)
ran = getRandom('.mp3','.mp4')
exec(`ffmpeg -i ${bas} -af equalizer=f=70:width_type=o:width=2:g=30 ${ran}`, (err, stderr, stdout) => {
fs.unlinkSync(bas)
if (err) return reply('Error!')
hah = fs.readFileSync(ran)
client.sendMessage(from, hah, audio, {mimetype: 'audio/mp4', ptt:true, quoted: mek})
fs.unlinkSync(ran)
})
break

				//FIM DOS COMANDOS DE √ÅUDIO
				//_COMANDOS DE VOZ
case 'oi':
tujuh = fs.readFileSync('./assets/ola.mp3');
client.sendMessage(from, tujuh, MessageType.audio, {quoted: mek, mimetype: 'audio/mp4', ptt:true})
break

case 'augusto':
tujuh = fs.readFileSync('./assets/augusto.mp3');
client.sendMessage(from, tujuh, MessageType.audio, {quoted: mek, mimetype: 'audio/mp4', ptt:true})
break
				
				case 'blocklist':
					teks = 'Esta √© a lista de n√∫meros bloqueados: \ n√∫mero '
					for (let block of blocked) {
						teks += `~> @${block.split('@')[0]}\n`
					}
					teks += `Total : ${blocked.length}`
					client.sendMessage(from, teks.trim(), extendedText, {quoted: mek, contextInfo: {"mentionedJid": blocked}})
					break
				
				case 'gtts':
					if (args.length < 1) return client.sendMessage(from, 'Qual codigo de linguagem?', text, {quoted: mek})
					const gtts = require('./lib/gtts')(args[0])
					if (args.length < 2) return client.sendMessage(from, 'Onde est√° o texto?', text, {quoted: mek})
					dtt = body.slice(9)
					ranm = getRandom('.mp3')
					dtt.length > 600
					? reply('O texto √© muito grande')
					: gtts.save(ranm, dtt, function() {
						client.sendMessage(from, fs.readFileSync(ranm), audio, {quoted: mek, mimetype: 'audio/mp4', ptt:true})
						fs.unlinkSync(ranm)
					})
					break
				case 'meme':
					meme = await fetchJson('https://kagchi-api.glitch.me/meme/memes', { method: 'get' })
					buffer = await getBuffer(`https://imgur.com/${meme.hash}.jpg`)
					client.sendMessage(from, buffer, image, {quoted: mek, caption: '.......'})
					break
				   case 'promover':
					if (!isGroup) return reply(mess.only.group)
					if (!isGroupAdmins) return reply(mess.only.admin)
					if (!isBotGroupAdmins) return reply(mess.only.Badmin)
					if (mek.message.extendedTextMessage === undefined || mek.message.extendedTextMessage === null) return
					mentioned = mek.message.extendedTextMessage.contextInfo.mentionedJid
					if (mentioned.length > 1) {
						teks = 'Promovido com sucesso\n'
						for (let _ of mentioned) {
							teks += `@${_.split('@')[0]}\n`
						}
						mentions(from, mentioned, true)
						client.groupRemove(from, mentioned)
					} else {
						mentions(`Promovido com sucesso @${mentioned[0].split('@')[0]} como administrador do grupo!`, mentioned, true)
						client.groupMakeAdmin(from, mentioned)
					}
					break
				case 'rebaixar':
					if (!isGroup) return reply(mess.only.group)
					if (!isGroupAdmins) return reply(mess.only.admin)
					if (!isBotGroupAdmins) return reply(mess.only.Badmin)
					if (mek.message.extendedTextMessage === undefined || mek.message.extendedTextMessage === null) return
					mentioned = mek.message.extendedTextMessage.contextInfo.mentionedJid
					if (mentioned.length > 1) {
						teks = 'Rebaixado com sucesso\n'
						for (let _ of mentioned) {
							teks += `@${_.split('@')[0]}\n`
						}
						mentions(teks, mentioned, true)
						client.groupRemove(from, mentioned)
					} else {
						mentions(`Voc√™ foi rebaixado @${mentioned[0].split('@')[0]} . Agora voc√™ √© s√≥ mais um membro comum!`, mentioned, true)
						client.groupDemoteAdmin(from, mentioned)
					}
					break
				case 'kick':
					if (!isGroup) return reply(mess.only.group)
					if (!isGroupAdmins) return reply(mess.only.admin)
					if (!isBotGroupAdmins) return reply(mess.only.Badmin)
					if (mek.message.extendedTextMessage === undefined || mek.message.extendedTextMessage === null) return reply('Tag target yang ingin di tendang!')
					mentioned = mek.message.extendedTextMessage.contextInfo.mentionedJid
					if (mentioned.length > 1) {
						teks = 'Pedido recebido, emitido :\n'
						for (let _ of mentioned) {
							teks += `@${_.split('@')[0]}\n`
						}
						mentions(teks, mentioned, true)
						client.groupRemove(from, mentioned)
					} else {
						mentions(`Pedido recebido, emitido : @${mentioned[0].split('@')[0]}`, mentioned, true)
						client.groupRemove(from, mentioned)
					}
					break
				case 'admins':
					if (!isGroup) return reply(mess.only.group)
					teks = `Lista de admin do grupo *${groupMetadata.subject}*\nTotal : ${groupAdmins.length}\n\n`
					no = 0
					for (let admon of groupAdmins) {
						no += 1
						teks += `[${no.toString()}] @${admon.split('@')[0]}\n`
					}
					mentions(teks, groupAdmins, true)
					break
                
				case 'toimg':
					if (!isQuotedSticker) return reply('‚ùå Falha ‚ùå')
					reply(mess.wait)
					encmedia = JSON.parse(JSON.stringify(mek).replace('quotedM','m')).message.extendedTextMessage.contextInfo
					media = await client.downloadAndSaveMediaMessage(encmedia)
					ran = getRandom('.png')
					exec(`ffmpeg -i ${media} ${ran}`, (err) => {
						fs.unlinkSync(media)
						if (err) return reply('‚ùå Falha ao converter o adesivo em imagem ‚ùå')
						buffer = fs.readFileSync(ran)
						client.sendMessage(from, buffer, image, {quoted: mek, caption: 'Prontinho.'})
						fs.unlinkSync(ran)
					})
					break
				
				
				case 'welcome':
					if (!isGroup) return reply(mess.only.group)
					if (!isGroupAdmins) return reply(mess.only.admin)
					if (args.length < 1) return reply('Hmm, tente novamente o comando *certo* para ativar o Welcome')
					if (Number(args[0]) === 1) {
						if (isWelkom) return reply('J√° ativo hmm')
						welkom.push(from)
						fs.writeFileSync('./src/welkom.json', JSON.stringify(welkom))
						reply('Ativado com sucesso o recurso Boas vindas do grupo‚úîÔ∏è')
					} else if (Number(args[0]) === 0) {
						welkom.splice(from, 1)
						fs.writeFileSync('./src/welkom.json', JSON.stringify(welkom))
						reply('Desativar com sucesso o recurso de boas-vindas neste grupo ‚úîÔ∏è')
					} else {
						reply('Welcome 1 para habilitar e Welcome 0 para desabilitar')
					}
                                      break
				case 'clone':
					if (!isGroup) return reply(mess.only.group)
					if (!isGroupAdmins) return reply(mess.only.admin)
					if (args.length < 1) return reply('Marque o alvo que voc√™ deseja clonar')
					if (mek.message.extendedTextMessage === undefined || mek.message.extendedTextMessage === null) return reply('Tag cvk')
					mentioned = mek.message.extendedTextMessage.contextInfo.mentionedJid[0]
					let { jid, id, notify } = groupMembers.find(x => x.jid === mentioned)
					try {
						pp = await client.getProfilePicture(id)
						buffer = await getBuffer(pp)
						client.updateProfilePicture(botNumber, buffer)
						mentions(`Foto do perfil atualizada com sucesso @${id.split('@')[0]}`, [jid], true)
					} catch (e) {
						reply('Falhou')
					}
					break
				case 'wait':
					if ((isMedia && !mek.message.videoMessage || isQuotedImage) && args.length == 0) {
						reply(mess.wait)
						const encmedia = isQuotedImage ? JSON.parse(JSON.stringify(mek).replace('quotedM','m')).message.extendedTextMessage.contextInfo : mek
						media = await client.downloadMediaMessage(encmedia)
						await wait(media).then(res => {
							client.sendMessage(from, res.video, video, {quoted: mek, caption: res.teks.trim()})
						}).catch(err => {
							reply(err)
						})
					} else {
						reply('Marque uma foto de anime')
					}
					break
				default:
					if (isGroup && isSimi && budy != undefined) {
						console.log(budy)
						muehe = await simih(budy)
						console.log(muehe)
						reply(muehe)
					} else {
						return //console.log(color('[WARN]','red'), 'Unregistered Command from', color(sender.split('@')[0]))
					}
                           }
		} catch (e) {
			console.log('Error : %s', color(e, 'red'))
		}
	})
}
starts()
